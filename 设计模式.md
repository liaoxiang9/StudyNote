# 设计模式学习笔记

## 面向对象设计原则

1. 依赖倒置原则（DIP）
   - 高层模块（稳定）不应该依赖于低层模块（变化），二者都应该依赖于抽象（稳定）。
   - 抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖于抽象（稳定）。
2. 开放封闭原则 （OCP）
   - 对扩展开放，对更改封闭
   - 类模块应该是可扩展的，但是不可修改的
3. 单一职责原则（SRP）
   - 一个类应该仅有一个引起它变化的原因
   - 变化的方向隐含着类的责任，职责太多时会导致扩展时对代码东拉西扯，造成混乱
4. Liskov替换原则（LSP）
   - 子类必须能够替换他们的基类
   - 继承表达类型抽象
5. 接口隔离原则（ISP）
   - 接口应该小而完备
   - 不应该强迫客户程序依赖他们不用的方法
6. 优先使用对象组合，而不是类继承
   - 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”
   - 继承在某种程度上破坏了封装性，子类父类耦合度高
   - 而对象组合则要求组件具备良好定义的接口
7. 封装变化点
    - 使用封装来创建对象之间
8. 针对接口编程，而不是针对实现编程

产业强盛的标志：接口标准化！

### 忌

设计模式的应用不宜先入为主，一上来就使用设计模式是对设计模式的最大误用。没有一步到位的设计模式。敏捷软件开发所提倡的“Refactoring to Patterns”是目前普遍公认的最好的设计模式的方法。

### 重构关键技法

- 静态->动态
- 早绑定->晚绑定
- 继承->组合
- 编译时依赖->运行时依赖
- 紧耦合->松耦合

## 模板方法(Template Method)

在软件构建过程中，对于某一项任务，他常常有稳定的整体操作结构。
作为一个基类，应该把析构函数写成虚的
**定义一个操作中的算法的骨架（稳定）而将一些步骤延迟（变化）到子类中。Template Method 使得子类可以不改变（复用）一个算法的结构即可重定义（override重写）该算法的某些特定步骤。**

```C++
class Library{
public:
    // 稳定 Template Method
    void Run(){
        Step1();
        if(Step2()){ // 可变==>虚函数的多态调用
            Step3();
        }
        for(int i=0;i<4;i++){
            Step4(); // 可变==>虚函数的多态调用
        }
        Step5();
    }
    virtual ~Library(){}
protected:
    // 纯虚函数（让子类重写）
    virtual void Step2() = 0;
    virtual void Step4() = 0;
    // 非虚函数
    void Step1(){
        ...
    }
    void Step3(){
        ...
    }
}

class Application1:public Library{
protected:
// 重写
    virtual void Step2(){
        ...
    }
    virtual void Step4(){
        ...
    }
}

```

### 注意

- 一个软件结构不能全是稳定的，也不能全是可变的，这样的软件结构是不需要设计模式的。
- 一个软件结构中，稳定的部分和可变的部分应该被分离开来，以便进行不同的处理。
- **设计代码前先画出每个类的类图，观察其中哪些部分是稳定的，哪些部分是可变的，然后再进行设计。**
- c++规定，当一个成员函数被声明为虚函数后，其派生类中的同名函数都自动成为虚函数。因此，在子类从新声明该虚函数时，可以加，也可以不加，但习惯上每一层声明函数时都加virtual,使程序更加清晰。

### 总结

1. Template Method 定义了一个算法的骨架，而将一些步骤延迟到子类中。是一种非常基础的设计模式，在面向对象系统中有着大量的应用。它用最简洁的机制（虚函数的多态性）为很多应用程序框架提供了灵活性，是代码复用方面的基石。
2. 除了可以灵活应对子步骤的变化外，“不要调用（或者引用）我们（早），我们会调用（或者引用）你（晚）”这一反转控制结构也是 Template Method 的重要特征。
3. 在具体实现方面，被Template Method调用的方法可以是抽象方法，也可以是具体方法。如果是抽象方法，那么子类必须实现它；如果是具体方法，那么子类可以根据需要对它进行重写。一般推荐将它们设置为 protected 方法，这样既可以被子类重写，又不会暴露给外界。

## 策略模式

### 动机

- 在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；而且有时候支持不使用的算法也是一个性能负担。

- 如何在运行时根据需要透明地更改对象的算法呢？将算法的使用、算法的实现分离开来。

### C++枚举类型详解

1. 枚举类型是一种数据类型，它的值是由程序员在程序中定义的一组整型常量组成的。
2. 枚举类型的用法：

```c++
enum 枚举名{枚举元素1，枚举元素2，...，枚举元素n};
```

3. 枚举类型的定义：

```c++
enum Color{red,green,blue};
```

4. 枚举类型的使用：

```c++
Color c1 = red;
Color c2 = green;
Color c3 = blue;
```

### 策略模式举例

1. 静态

```c++
enum TaxBase{
    CN_Tax,
    US_Tax,
    EU_Tax,
    JP_Tax // 更改
};
class SalesOrder{
    TaxBase tax;
public:
    double calculate(){
        if(tax == CN_Tax){
            // 计算中国税
    }
    else if(tax == US_Tax){
        // 计算美国税
    }
    else if(tax == EU_Tax){
        // 计算欧盟税
    }
    else if(tax == JP_Tax){ // 更改
        // 计算日本税
    }
    }
};
```

上述代码打破了开放封闭原则。

2. 动态

    ```c++
    class TaxBase{
    public:
        virtual double calculate() = 0;
        // 基类的析构函数必须是虚函数
        virtual ~TaxBase(){};
    };
    class CN_Tax:public TaxBase{
    public:
        double calculate(){
            // 计算中国税
        }
    };
    class US_Tax:public TaxBase{
    public:
        double calculate(){
            // 计算美国税
        }
    };
    class EU_Tax:public TaxBase{
    public:
        double calculate(){
            // 计算欧盟税
        }
    };
    // 当需要增加新的税种时，只需要增加新的类即可（增加一个新的文件即可）
    class JP_Tax:public TaxBase{ // 更改
    public:
        double calculate(){
            // 计算日本税
        }
    };
    class SalesOrder{
    private:
        // 用指针来指向不同的税种，必须用指针指向父类，才可以实现多态
        TaxBase* tax;
    public:
        SalesOrder(TaxBase* tax){
            this->tax = tax;
        }
        double calculate(){
            // 调用不同的税种的calculate方法（多态）
            return tax->calculate();
        }
    };

    int main(){
        SalesOrder* order = new SalesOrder(new CN_Tax());
        order->calculate();
        delete order;
        return 0;
    }
    ```

### 注意

1. C++中的代码复用是指二进制代码的复用，而不是源代码的复用。C++中的代码复用是通过继承和多态来实现的。

2. 基类的析构函数必须是虚函数，否则会造成内存泄漏，使用基类的指针来指向派生类的对象，如果基类的析构函数不是虚函数，那么在delete基类的指针时，只会调用基类的析构函数，而不会调用派生类的析构函数，这样就会造成派生类的对象没有被释放，造成内存泄漏，而且如果基类的析构函数是虚函数，那么在delete基类的指针时，会调用派生类的析构函数，这样就可以释放派生类的对象。对此举例：

```c++
class Base{
public:
    virtual ~Base(){
        cout << "Base::~Base()" << endl;
    }
};
class Derived:public Base{
public:
    ~Derived(){
        cout << "Derived::~Derived()" << endl;
    }
};
int main(){
    Base* b = new Derived();
    delete b;
    return 0;
}
```

输出结果：

```c++
Derived::~Derived()
Base::~Base()
// 先调用派生类的析构函数，再调用基类的析构函数
```

3. C++中的多态是静态多态，即在编译时就已经确定了调用哪个函数，而不是在运行时才确定调用哪个函数。C++中的多态是通过虚函数来实现的，虚函数是在基类中声明为虚函数的函数，派生类中的同名函数会覆盖基类中的同名函数，但是在调用时，会根据指针的类型来调用不同的函数，而不是根据指针所指向的对象的类型来调用不同的函数。对此举例：

### 模式定义

定义一系列算法，把它们一个个封装起来，并且使它们可以相互替换。本模式使得算法可独立于使用它的客户而变化（扩展、子类化）。

### 要点总结

1. 策略模式及其子类为组件提供了一系列可重用的算法，从而可以使得类型在**运行时**方便地根据需要在各个算法之间进行切换。
注意**if-else**的使用，最好是针对**绝对不变**的场景，如果是**相对不变**的场景，最好使用策略模式。
2. 策略模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要策略模式。
3. 如果策略模式对象没有实例变量，那么各个上下文可以共享同一个策略对象，从而节省对象开销。
